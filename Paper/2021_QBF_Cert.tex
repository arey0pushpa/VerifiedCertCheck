\documentclass[runningheads]{llncs}

%\let\pf=\proof
%\renewenvironment{proof}{\begin{pf}}{\qed\end{pf}}
\usepackage{url}\urlstyle{rm}

\RequirePackage{amsmath}
\usepackage{algpseudocode}
%\usepackage{algorithm}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{verbatim,amssymb,amsfonts,amscd,graphicx}
\usepackage{bussproofs}
\usepackage{color}
%\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{times}
\usepackage{placeins}
\usepackage{thmtools}
%\usepackage{enumitem}
\usepackage[shortlabels]{enumitem} 
\usepackage{cite}
\usepackage{url}
\usepackage{lmodern}
\usepackage{booktabs}
\usepackage[justification=justified]{caption}
\newcommand{\qrpcert}{\mathsf{QBFCert}}
\newcommand{\qtrim}{\mathsf{QRATtrim}}

\newcommand{\bloqqer}{\mathsf{Bloqqer}}
\newcommand{\cheskol}{\mathsf{cheskol}}
%\newfloatcommand{capbtabbox}{table}[][\FBwidth]

%\spnewtheorem{theorem}{Theorem}
%\spnewtheorem{corollary}{Corollary}
%\spnewtheorem{lemma}{Lemma}
%\spnewtheorem{proposition}{Proposition}
%\spnewtheorem{conjecture}{Conjecture} 
%\spnewtheorem{question}{Question} 
%\spnewtheorem{observation}{Observation}
\spnewtheorem{plaindefinition}{Definition}{\bfseries}{\normalfont}

% GENERAL MACROS
\def\hy{\hbox{-}\nobreak\hskip0pt} \newcommand{\ellipsis}{$\dots$}
\newcommand{\SB}{\{\,} \newcommand{\SM}{\;{:}\;} \newcommand{\SE}{\,\}}
\newcommand{\Norm}[1]{\Vert #1 \Vert}
\newcommand{\Card}[1]{|#1|}
\newcommand{\red}{\color{red}}
\newcommand{\blue}{\color{blue}}
\renewcommand{\iff}{\Longleftrightarrow}

% PAPER SPECIFIC MACROS
\newcommand{\var}{\mathit{var}}
\newcommand{\lit}{\mathsf{lit}}
\newcommand{\fff}{\varphi}
\newcommand{\matrixf}{\phi}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\qp}{\mathcal{Q}}
\newcommand{\qt}{\mathit{qtype}}
\newcommand{\FFF}{\Phi}
\newcommand{\GGG}{\Psi}
\newcommand{\rightOf}{R}

\newcommand{\0}{0}
\newcommand{\1}{1}
\usepackage{upgreek}

\def\universals{U_\mathcal{Q}}
\def\existentials{E_\mathcal{Q}}
\def\qlvl{\mathsf{lev_\qp}}
\def\mcount{\mathsf{ModelCount}}
\def\outvar{\mathsf{OutermostVar}}
\def\coveredbranch{\mathsf{SATSolver}}
\def\ass{\mathsf{SATAssignment}}
\def\iblock{\mathsf{IncrementalBlocking}}
\def\pcount{\mathsf{CountSATPosBranches}}
\def\ncount{\mathsf{CountSATNegBranches}}

\usepackage{stackengine}
\def\models{\mathsf{Models}}
\def\qcert{\mathsf{QBFCert}}
\def\comba{\mathsf{Combinatorial_1}}
\def\combb{\mathsf{Combinatorial_2}}

\newcommand{\Neg}[1]{\overline{#1}}
\newcommand{\rd}[2]{#1[#2]}
\newcommand{\rc}[2]{#1[#2]}
\newcommand{\cc}[1]{Cl(#1)}
\renewcommand{\P}{\mathcal{P}}

% MACROS IMPORTED FROM THE OTHER PAPER ON SOUNDNESS OF Q(D)-RESOLUTION
\newcommand{\Dtrv}{\normalfont \text{D}^{\text{\normalfont trv}}}
\newcommand{\Dst}{\text{D}^{\text{\normalfont std}}}
\newcommand{\Dres}{\text{D}^{\text{\normalfont res}}}
\newcommand{\Resord}{<^{\text{\normalfont res}}}
%\newcommand{\Drrs}{\text{\textnormal D}^{\text{\normalfont rrs}}}
\newcommand{\Drrs}{{\normalfont \text{D}^{\text{{\normalfont rrs}}}}}
\newcommand{\Dmat}{D^{\text{\normalfont mat}}}
\newcommand{\Dtri}{D^{\text{\tiny $\triangle$}}}
\newcommand{\Dtris}{D^{\text{\tiny $\triangle_s$}}}
\newcommand{\AAA}{\mathcal{A}} \newcommand{\BBB}{\mathcal{B}}
\newcommand{\CCC}{\mathcal{C}} \newcommand{\DDD}{\mathcal{D}}
\newcommand{\LLL}{\mathcal{L}} 
\newcommand{\HHH}{\mathcal{H}}
\newcommand{\MMM}{\mathcal{M}} \newcommand{\PPP}{\mathcal{P}}
\newcommand{\QQQ}{\mathcal{Q}}
\newcommand{\SSS}{\mathcal{S}} \newcommand{\TTT}{\mathcal{T}}
\newcommand{\VVV}{\mathcal{V}} \newcommand{\bigoh}{\mathcal{O}}

% QED AT THE END OF PROOFS
\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

% Additonal macros for the paper: added by Ankit
\usepackage{xspace}
\usepackage{upgreek}
\usepackage{mathtools}
\usepackage{todonotes}
\usepackage{float,subcaption}
\captionsetup{compatibility=false}
\SetKwRepeat{Do}{do}{while}%

\newcommand{\sff}[1]{{\normalfont \textsf{#1}}}
\def\qbf{\sff{\#QBF}\xspace}
\def\qbff{\textsf{\#QBF}\xspace}
\def\pspace{\sff{\#PSPACE}\xspace}

\usepackage{tikz}
\usetikzlibrary{tikzmark,decorations.pathreplacing,arrows,shapes,positioning,shadows,trees,shapes.gates.logic.US,arrows.meta,shapes,automata,petri,calc}
\usetikzlibrary{positioning}

\newcommand{\highlight}[3]{
	\pgfmathsetmacro{\innerlinewidth}{0.9 * #1}
	\path [my box, opacity=0.2, line width = \innerlinewidth, draw = #2] #3;
}

\makeatletter
\newcommand{\shorteq}{%
	\settowidth{\@tempdima}{-}% Width of hyphen
	\resizebox{\@tempdima}{\height}{=}%
}
\makeatother

\def\Equal{$\,\texttt{:=}\,$}


\definecolor{tgreen}{RGB}{179, 250, 179}
\definecolor{tred}{RGB}{246, 34, 34}
\tikzset{
	my box/.style = {
		, line cap = round
		, line join = round
	}
}
% ----------------- End of the macros


%\usepackage{graphicx} : Already included 
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%\raggedright
%\pagestyle{empty}

%
\title{Verified Resolution-Based QBF Certificate Checking}


%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Peter Lammich\inst{1} \and Ankit Shukla\inst{1}}
%\orcidID{1111-2222-3333-4444}

%\authorrunning{.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Manchester, United Kingdom \and JKU, Linz, Austria \\
\email{lammich@in.tum.de, ankit.shukla@jku.at}
}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract} 
 XXX

\keywords{QBFs \and  Theorem proving \and Issabella}
\end{abstract}

\section{Introduction}
\label{sec:intro}
Quantified Boolean formulas (QBFs) is an extension of propositional formulas with existential and universal quantifiers over the propositional variables. The use of quantifiers provides more succinct encoding of problems than with just propositional variables. For example QBF encoding of Bounded model checking (BMC) problem \cite{DershowitzHK05} can be exponentially more compact than corresponding propositional encoding. However, this comes with a price, QBFs are much more difficult to solve than propositional formulas. The decision problem of propositional satisfiability (SAT) is NP-complete \cite{Cook71} whereas, the decision problem of QBFs (QSAT) is the prototypical PSPACE-problem \cite{StockmeyerM73}. QBF is a powerful host language for many application domains in automated reasoning and artificial intelligence, including planning \cite{AnsoteguiGS05, EglyKLP17, Cashmore2012planning, Gasquet18}, verification \cite{MillerSB13} and synthesis \cite{BloemKS14, BloemEKKL14, Gange2014synthesizing}.

For many of the applications of QBFs, finding whether QBF is \textit{true} or \textit{false} is not enough and sometimes worthless. For instance, in BMC, if the safety property is violated, the tool should provide a counter-example. Therefore, in addition to bare yes/no answers, a QBF solver must provide \textit{certificates} to construct the counter-examples. In comparison to SAT, the QBF technology is still in the early stages of it's development, and the solvers are relatively more error-prone. To establish the trust in the correctness of a QBF solver certificates are a must. Most of the modern QBF solvers in addition to solve the satisfiability problem of the formula produce certificates \cite{Balabanov2015, RabeS16, BalabanovJ12, Benedetti05, NarizzanoPPT09, NiemetzPLSB12, JussilaBSKW07, GoultiaevaGB11, Van2013, HeuleSB17}. The most general format of the certificate is a set of Skolem (Herbrand) functions representing a model for a true (false) QBF. 
A complete certification process will ensure the correctness of the solver's result and enables reasoning tasks that require a witness. 
%For example, similar to SAT competitions, validate the results of QBF solvers in the QBF competitions, replacing the current practice of just relying on the majority votes. 

We address two of the major bottlenecks in the adoption of the certificate extraction process. First, provide complete confidence in the result of the solver. Second, generate and verify the certificates with a marginal overhead to the solving time. 
We present an approach of a formally verified certificate generation and checking to ensure complete trust in the result of the solver and the generated Skolem functions. The certification validation process poses an additional overhead over the verification process, for example, the resolution based QBF solver DepQBF \cite{LonsingB10} takes as much time to generate and validate the Skolem function as it takes to solve the original instance. Certificate validation is the main bottleneck in the overall process \cite{NiemetzPLSB12}, where the generated Skolem function is checked against the original formula for correctness using a SAT solver. In \cite{NiemetzPLSB12} more than 77\% of the certification time is spent to validate the certificate. Our approach eliminates the use of the explicit validation process (SAT solver call) and verify the certificates with a marginal overhead. We show the effectiveness of our approach in the resolution-based certificate extraction \cite{NiemetzPLSB12}; our approach can be adopted for other QBF solving techniques.

Formal verification (automated/interactive theorem proving) approach \cite{Fleury2018a, Fleury2019a, BlanchetteFLW18} and verified certificate checking \cite{Cruz2017, Cruz2017b, Heule2017a, Lammich17} is used recently in SAT solving. This approach provides guaranteed confidence in the result of the solver and has revealed critical bugs \cite{Lammich17} in unverified tools. 

To our best knowledge, this is the first application of the verified approach in QBFs. We hope the approach developed in this paper will generate more interest in automated verification of QBFs and lead us closer to the adoption of efficient verified certification checking with minimal overhead. \\
 
 
\textbf{DepQBF Use Cases}: 
Following are the examples that require DepQBF with function synthesis and simple yes/no answer is not enough:
 
\begin{enumerate}
 	\item In BMC or reachability analysis \cite{BloemKS14}, if the safety property is violated, the tool should provide a counter-example. 
 	
 	\item Planning as Quantified Boolean Formula \cite{Cashmore2012planning, EglyKLP17, Gasquet18}. The strategy for the outermost existential variable corresponds to a plan. 
 	\item In hardware circuit synthesis \cite{BloemEKKL14, BloemKS14, Faymonville2017, Subramanyan2013, Li2013} it's not enough to know if there exist an implementation. A strategy is required, to construct a circuit that implements a blackbox. In \cite{Subramanyan2013, Li2013} the problem is modeled as a 2QBF. Synthesizing optimal switching lattices \cite{Gange2014synthesizing}: problem is encoded as 2QBF. 
 	\item Firewalls verification and synthesis \cite{Zhang2012verification}. The problem was encoded as 2QBF. Synthesized assignment amounts to the definition of rules of the firewall.
 	\item Biological networks synthesis \cite{GuptaMS18}; completion of the network and predicting activities of the molecules with incomplete information requires Skolem function to be synthesized to develop wet experiments in laboratories.  
\end{enumerate}

\textbf{Other Use Cases} (Yes/No answer is sufficient):

\begin{enumerate}
    \item Cryptography: DepQBF solver was used to verify whether the precondition holds in a secure multiparty computation \cite{Launchbury2014application}. 
	\item Application to AI (argumentation frameworks): abstract dialectical frameworks \cite{Brewka2020solving, Diller2014reasoning}. ADF is compiled to a QBF and solved using DepQBF.
	\item Adversarial games: Tic-Tac-Toe \cite{DiptaramaYS16}.
\end{enumerate}

\section{Preliminaries}
\label{sec:pre}

We consider QBFs $\FFF = {\qp}.\matrixf$ in prenex conjunctive normal form (PCNF) where $\qp$ = $Q_{1} v_{1} \ldots Q_{n} v_{n}$ with $Q_{i} \in \{\forall, \exists \}$ and $\matrixf$ is a propositional formula represented as conjunction of clauses over the set of variables $V = \{v_{1}, \ldots, v_{n}\}$. We call $\qp$ the \textit{quantifier prefix} and $\matrixf$ the \textit{matrix} of the QBF $\Phi$. A clause is a disjunction of \textit{literals} and a literal is a variable $v$ or it's negation $\neg v$. We also write clauses as sets of literals. The \textit{complement} of a literal $l$ is denoted as $\overline{l}$, i.e. $\overline{v} = \neg v$, $\overline{\neg{v}} = v$. If $l = v$ or $l = \neg v$, $\var(l) = v$.

The qunatifier prefix of a QBF is partitioned into subsequent different \textit{quantifier blocks}, each of which is a maximal subsequence $\exists x_{1} \ldots \exists x_{n}$ or $\forall y_{1} \ldots \forall y_{m}$. We denote the ith quantifier block by $\qp(i)$. For literal $l$, $\qlvl(l) = i$ if $\var(l) \in \qp(i)$. For literals $l, k$, it holds that $l <_\qp k$ if $\qlvl(l) = i$, $\qlvl(k) = j$, and $k < j$. If $\qp$ consists of $k$ quantifier blocks, i.e., $|\qp| = k$,  we call $\qp({k})$ the innermost quantifier block and $\qp({1})$ the outermost quantifier block. By $\universals$ and $\existentials$, we denote the set of universal and existential variables occurring in $\qp$. 

An \textit{assignment} is a mapping of variables to boolean values $\1, \0$. We use a function $\sigma \colon V' \to \{\1, \0 \}$ to represent an assignment of variables $V^{\prime} \subseteq V$. If $V^{\prime} = V$ we call the assignment \emph{total}, otherwise we call it \emph{partial}. For a matrix $\matrixf$ and partial assignment $\sigma$, we write $\matrixf|_{\sigma}$ for the formula obtained after applying the partial assignment $\sigma$ to $\matrixf$, i.e., for every $v$ $\in$ $\sigma$ we replace all occurrences of $v$ in $\phi$ with $\sigma(v)$ and perform standard propositional simplifications.
%We assume the standard QBF semantics. The semantics of a QBF is defined re ursively: a QBF $\sexists x\qp.\matrixf$ is true if and only if $\qp.\matrixf|_{x=\1}$ or $\qp.\matrixf|_{x=\0}$ is true and a QBF $\forall y\qp.\matrixf$ is true if and only if both $\qp.\matrixf|_{y=\1}$ and $\qp.\matrixf|_{y=\0}$ are true.
A closed PCNF formula is true if and only if there exists an assignment of truth values to the existential variables depending on the preceding universal variables in the quantifier prefix such that the matrix of the formula is true for all values of the universal variables.
%

QBF satisfiability can be understood as a two players zero sum game. There are two players in the game: the existential player; owns the existentially quantified variables, and the universal player, owns the universally quantified variables. A single round of play is as follows: step through the variable in the quantifier prefix, the player who owns it assigns it a value. The existential player wins a round of the game if the constructed assignment satisfies all clauses in the matrix, otherwise the universal player wins. A QBF is true if and only if the existential player has a winning strategy that allows him to win irrespective how the universal player plays. A QBF is false if and only if the universal player has a winning strategy. 
%Thus, a strategy for the universal player, and a proof that it is a winning strategy, is a proof that the QBF is false.

XXX

\section{Related Work} \label{sec:related-work}

A complete framework for generating QBF certificates from resolution proofs obtained by the QBF solver DepQBF was presented in \cite{NiemetzPLSB12}. The tool $\qrpcert$ extracts the Skolem function \cite{BalabanovJ11} from the Q-Resolution trace produced by DepQBF solver. The Skolem function is represented as AIGs. Certificate validation is performed by first translating the input formula into an AIG  and merging it with the certificate. Then the resulting AIG is translated into a CNF and use a SAT solver to check the validity. Figure \ref{fig:tool} (a) shows the overview of the tool. $\qrpcert$ does not support the advance dependency scheme used by DepQBF and the certificate validation is the most expensive step of the tool-chain.  
 
\tikzstyle{block} = [draw, fill=red!10, rectangle, rounded corners,
minimum height=4em, minimum width=7em]
\tikzstyle{block4} = [draw, fill=blue!10, rectangle, rounded corners,
minimum height=4em, minimum width=7em]
\tikzstyle{block1} = [draw, fill=green!10, rectangle, rounded corners,
minimum height=4em, minimum width=7em]
\tikzstyle{block2} = [draw, fill=green!10, rectangle, rounded corners,
minimum height=4em, minimum width=7em]
\tikzstyle{bigblock} = [draw, fill=red!10, rectangle, rounded corners,
minimum height=8em, minimum width=7em]
\tikzstyle{smallblock1} = [draw, fill=brown!15, rectangle, rounded corners,
minimum height=4em, minimum width=4em]
\tikzstyle{sum} = [draw, fill=blue!20, circle, minimum size=2mm]
\tikzstyle{sum1} = [draw, fill=blue!20, circle, minimum size=1mm]

\tikzstyle{smallsum} = [draw, fill=blue!20, circle, minimum size=0.1mm]

\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thick,red}]
\tikzstyle{snakeline} = [connector, decorate, decoration={pre length=0.2cm,
	post length=0.2cm, snake, amplitude=.4mm,
	segment length=2mm},thick, magenta, ->]

\tikzstyle{pre}=[<-,shorten <=1pt,>=stealth’,semithick]
\tikzstyle{post}=[->,shorten >=1pt,>=stealth’,semithick]

\begin{figure}	
	 \centering
	\begin{subfigure}[t]{0.5\textwidth}
		\centering
\begin{tikzpicture}[auto, node distance=2.0cm,>=latex', font = \sffamily, every text node part/.style={align=center}]

\node [block, name=input] (controller) {DepQBF};
\node [block2, name=input,below of=controller] (prop) {QRPCert};  
pin={[pinstyle]above:}

\node [sum, above of=controller, node distance=1.2cm] (system) {};
\node [right of=prop, node distance=2.6cm] (skolemf) {$f$};
	    
\draw [->,semithick] (system) -- node[name=w] {\textsf{QBF $\FFF$}} (controller);

\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (controller) -- node[name=u] {trace} (prop);

\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (prop) -- node[name=u] {Skolem} (skolemf);

\end{tikzpicture}
		\caption{Skolem extraction; no pre-processing}
	\end{subfigure}%
	\begin{subfigure}[t]{0.5\textwidth}
		\centering
\begin{tikzpicture}[auto, node distance=1.5cm,>=latex', font = \sffamily, every text node part/.style={align=center}]

\node [block, name=input] (controller) {Bloqqer \\ (preprocc.)};


\node [sum, above of=controller, node distance=1.5cm] (system) {};
\draw [->,semithick] (system) -- node[name=w] {\textsf{QBF $\FFF$}} (controller);
% \node [smallsum, below of=controller, node distance=3.2cm] (sat) {};
\node [output, right of=controller, node distance=3.2cm] (unsat) {};    
\node [block1, right of=controller, node distance=3.7cm] (system) {QRATtrim};
\node [right of=system, node distance=2.4cm] (skolemf) {$f$};

\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (controller) -- node[name=u] {\textsf{SAT?}} (system);

\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (system) -- node[name=u] {Skolem} (skolemf);

\end{tikzpicture}
	\caption{Completely solved by pre-processing}
\end{subfigure}

\caption{Skolem function extraction without and with- preprocessing. Herbrand function can be extracted by $\qrpcert$ (a) but not supported by QRATtrim (b)}\label{fig:tool}
\end{figure}

Generally, QBF instance is first passed through a preprocessor to simplify the original instance. The original instance is rewritten to an equi-satisfiable formula which is then passed to the QBF solver. To handle the preprocessing techniques quantified resolution asymmetric tautology (QRAT) proof system was introduced in \cite{HeuleSB14a}. QRAT is a framework that allows verification of all preprocessing techniques for QBFs with three simple rules \cite{HeuleSB14a}. The implementation integrate QRAT-based tracing to the pre-processor $\bloqqer$ \cite{Biere2011} and present an efficient QRAT proof checker $\qtrim$.
In the subsequent work, \cite{HeuleSB14}, the authors extend the capabilities of $\qtrim$ to extract and validate the Skolem function from a completely solved instance after the pre-processing (by $\bloqqer$). 
%The validation of Skolem functions checks the dependencies and computes whether the Skolem functions imply the formula using the SAT solver is performed by a tool $\cheskol$.
Figure \ref{fig:tool} (b) show the architecture of the tool.
The main drawback of the approach is that it supports \textbf{only Skolem functions extraction} from formulas which are solved by the preprocessor. Skolem functions consider only deleted clauses of a proof whereas Herbrand functions consider both newly introduced clauses and updated clauses. Reason? May be : A clause addition step may even introduce new variables. XXX


The work \cite{FazekasHSB17} combines the partial Skolem function extracted from the QRAT trace and combine it with the Skolem function extracted by $\qcert$ of the pre-processed formula. The approach obtain Skolem functions with
all preprocessing techniques implemented in  $\bloqqer$ and allow the combination of $\bloqqer$ with any Skolem function producing solver. The approach is used to the extraction only Skolem functions and support for the Herbrand function extraction is left as a future work.

A similar approach to  \cite{FazekasHSB17} was developed in \cite{JanotaGM13} to obtain Skolem functions for a subset of the preprocessing techniques implemented in $\bloqqer$ by solution reconstruction rule for each of the supported preprocessing technique.



\begin{figure}[t]
	\centering
	\begin{tikzpicture}[auto, node distance=1.8cm,>=latex', font = \sffamily, every text node part/.style={align=center}]
	
	\node [block, name=input] (controller) {Bloqqer \\ (preprocc.)};
	\node [block, name=input,below of=controller] (prop1) {DepQBF};
	\node [block2, name=input, below of=prop1] (prop) {QRPCert};  
	
	\node [sum, above of=controller, node distance=1.5cm] (system) {};
	\draw [->,semithick] (system) -- node[name=w] {\textsf{QBF $\FFF$}} (controller);
	\node [right of=prop, node distance=2.8cm] (skolem) {$f^{\prime\prime}$};
	\node [output, right of=controller, node distance=3.2cm] (unsat) {};    
	\node [block1, left of=controller, node distance=3.8cm] (system) {QRATtrim};
	\node [block1, right of=controller, node distance=4cm] (system2) {sk-extract};
	\node [below of=system2, node distance=1.8cm] (skolem1) {$f^{\prime}$};
	\node [block4, name=input, right of=skolem] (prop4) {extract};  
	\node [right of=prop4, node distance=1.8cm] (skolemf) {$f$};
	\node [below of=system, node distance=1.8cm] (skolemf2) {$f$};
	
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (controller) -- node[name=u] {\textsf{SAT?}} (system);
	
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (prop1) -- node[right] {trace} (prop);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (controller) -- node[name=u] {QBF $\FFF^{\prime}$} (prop1);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (prop) -- node[name=u] {\textsf{Skolem}} (skolem);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (system2) -- node[name=u] {\textsf{Skolem}} (skolem1);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (skolem) -- node[name=u] {} (prop4);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (skolem1) -- node[name=u] {} (prop4);
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (prop4) -- node[name=u] {} (skolemf);  
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (system) -- node[name=u] {} (skolemf2);  
	\draw [->,thick,decorate,decoration={amplitude=.4mm,segment length=2mm,post length=1mm}] (controller) -- node[name=u] {QRAT trace} (system2);
	\end{tikzpicture}
	\caption{Tool chain of sk-extract. Skolem function can be extracted for Pre-processing combined with the QBF solving. No support for Herbrand function.}
\end{figure}

\noindent\textbf{News}:  QBF proof checking format QRAT cannot have polynomial time strategy extraction unless P = PSPACE \cite{ChewC20}.
\section{Program Verification with Isabelle/HOL} \label{sec:Isabelle}

XXX

\section{Conclusion} \label{sec:conclusion}

XXX

\bibliographystyle{unsrt}

%\bibliographystyle{splncs04}
\bibliography{literature}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
